// Generated by CoffeeScript 2.3.1
(function() {
  var Parser, alt, alternatives, grammar, name, o, operators, token, tokens, unwrap;

  ({Parser} = require('jison'));

  unwrap = /^function\s*\(\)\s*\{\s*return\s*([\s\S]*);\s*\}/;

  o = function(patternString, action, options) {
    var getAddDataToNodeFunctionString, match, patternCount, performActionFunctionString;
    patternString = patternString.replace(/\s{2,}/g, ' ');
    patternCount = patternString.split(' ').length;
    if (action) {
      action = (match = unwrap.exec(action)) ? match[1] : `(${action}())`;
      action = action.replace(/\bnew /g, '$&yy.');
      action = action.replace(/\b(?:Block\.wrap|extend)\b/g, 'yy.$&');
      getAddDataToNodeFunctionString = function(first, last) {
        return `yy.addDataToNode(yy, @${first}${(last ? `, @${last}` : '')})`;
      };
      action = action.replace(/LOC\(([0-9]*)\)/g, getAddDataToNodeFunctionString('$1'));
      action = action.replace(/LOC\(([0-9]*),\s*([0-9]*)\)/g, getAddDataToNodeFunctionString('$1', '$2'));
      performActionFunctionString = `$$ = ${getAddDataToNodeFunctionString(1, patternCount)}(${action});`;
    } else {
      performActionFunctionString = '$$ = $1;';
    }
    return [patternString, performActionFunctionString, options];
  };

  grammar = {
    Root: [
      o('',
      function() {
        return new Block;
      }),
      o('Body')
    ]
  };

  operators = [['left', '.', '?.', '::', '?::'], ['left', 'CALL_START', 'CALL_END'], ['nonassoc', '++', '--'], ['right', 'UNARY'], ['right', 'AWAIT'], ['right', '**'], ['right', 'UNARY_MATH'], ['left', 'MATH'], ['left', '+', '-'], ['left', 'SHIFT'], ['left', 'RELATION'], ['left', 'COMPARE'], ['left', '^'], ['left', '|'], ['left', '&&'], ['left', '||'], ['left', 'BIN?'], ['nonassoc', 'INDENT', 'OUTDENT'], ['right', 'YIELD'], ['right', '=', ':', 'COMPOUND_ASSIGN', 'RETURN', 'THROW', 'EXTENDS'], ['right', 'FORIN', 'FOROF', 'FORFORM', 'BY', 'WHEN'], ['right', 'IF', 'ELSE', 'FOR', 'WHILE', 'UNTIL', 'LOOP', 'SUPER', 'CLASS', 'IMPORT', 'EXPORT'], ['left', 'POST_IF']];

  tokens = [];

  for (name in grammar) {
    alternatives = grammar[name];
    grammar[name] = (function() {
      var i, j, len, len1, ref, results;
      results = [];
      for (i = 0, len = alternatives.length; i < len; i++) {
        alt = alternatives[i];
        ref = alt[0].split(' ');
        for (j = 0, len1 = ref.length; j < len1; j++) {
          token = ref[j];
          if (!grammar[token]) {
            tokens.push(token);
          }
        }
        if (name === 'Root') {
          alt[1] = `return ${alt[1]}`;
        }
        results.push(alt);
      }
      return results;
    })();
  }

  exports.parser = new Parser({
    tokens: tokens.join(' '),
    bnf: grammar,
    operators: operators.reverse(),
    startSymbol: 'Root'
  });

}).call(this);
