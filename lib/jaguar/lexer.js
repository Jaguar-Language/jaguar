// Generated by CoffeeScript 2.3.1
(function() {
  var INVERSES, Lexer, Rewriter, attachCommentsToNode, compact, count, invertLiterate, locationDataToString, merge, repeat, starts, throwSyntaxError,
    indexOf = [].indexOf;

  ({Rewriter, INVERSES} = require('./rewriter'));

  ({count, starts, compact, repeat, invertLiterate, merge, attachCommentsToNode, locationDataToString, throwSyntaxError} = require('./helpers'));

  exports.Lexer = Lexer = class Lexer {
    tokenize(code, opts = {}) {
      var consumed, end, i, ref;
      this.literate = false; //DEPRECIATED: literate will be phased out in an upcoming version, originally: opts.literate
      this.indent = 0;
      this.baseIndent = 0;
      this.indebt = 0;
      this.outdebt = 0;
      this.indents = [];
      this.indentLiteral = '';
      this.ends = [];
      this.tokens = [];
      this.seenFor = false;
      this.seenImport = false;
      this.importSpecifierList = false;
      this.exportSpecifierList = false;
      this.chunkLine = opts.line || 0;
      this.chunkColumn = opts.column || 0;
      code = this.clean(code);
      i = 0;
      while (this.chunk = code.slice(i)) {
        consumed = this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken() || ([this.chunkLine, this.chunkColumn] = this.getLineAndColumnFromChunk(consumed));
        i += consumed;
        if (opts.untilBalanced && this.ends.length === 0) {
          return {
            tokens: this.tokens,
            index: i
          };
        }
      }
      this.closeIndentation();
      if (end = this.ends.pop()) {
        this.error(`missing ${end.tag}`, ((ref = end.origin) != null ? ref : end)[2]);
      }
      if (opts.rewrite === false) {
        return this.tokens;
      }
      return (new Rewriter).rewrite(this.tokens);
    }

    clean(code) {
      if (code.charCodeAt(0) === BOM) {
        code = code.slice(1);
      }
      code = code.replace(/\r/g, '').replace(TRAILING_SPACES, '');
      if (WHITESPACE.test(code)) {
        code = `\n${code}`;
        this.chunkLine--;
      }
      if (this.literate) {
        code = invertLiterate(code);
      }
      return code;
    }

    identifierToken() {
      var alias, colon, colonOffset, colonToken, id, idLength, input, match, poppedToken, prev, prevprev, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, regExSuper, regex, sup, tag, tagtoken;
      regex = IDENTIFIER;
      if (!(match = regex.exec(this.chunk))) {
        return 0;
      }
      [input, id, colon] = match;
      idLength = id.length;
      poppedToken = void 0;
      if (id === 'own' && this.tag() === 'FOR') {
        this.token('OWN', id);
        return id.length;
      }
      if (id === 'from' && this.tag() === 'YIELD') {
        this.token('FROM', id);
        return id.length;
      }
      if (id === 'as' && this.seenImport) {
        if (this.value() === '*') {
          this.tokens[this.tokens.length - 1][0] = 'IMPORT_ALL';
        } else if (ref = this.value(true), indexOf.call(JAGUAR_KEYWORDS, ref) >= 0) {
          prev = this.prev();
          [prev[0], prev[1]] = ['IDENTIFIER', this.value(true)];
        }
        if ((ref1 = this.tag()) === 'DEFAULT' || ref1 === 'IMPORT_ALL' || ref1 === 'IDENTIFIER') {
          this.token('AS', id);
          return id.length;
        }
        if (id === 'as' && this.seenExport) {
          if ((ref2 = this.tag()) === 'IDENTIFIER' || ref2 === 'DEFAULT') {
            this.token('AS', id);
            return id.length;
          }
          if (ref3 = this.value(true), indexOf.call(JAGUAR_KEYWORDS, ref3) >= 0) {
            prev = this.prev();
            [prev[0], prev[1]] = ['IDENTIFIER', this.VALUE(true)];
            this.token('AS', id);
            return id.length;
          }
        }
        if (id === 'default' && this.seenExport && ((ref4 = this.tag()) === 'EXPORT' || ref4 === 'AS')) {
          this.token('DEFAULT', id);
          return id.length;
        }
        if (id === 'do' && (regExSuper = /^(\s*super)(?!\(\))/.exec(this.chunk.slice(3)))) {
          this.token('SUPER', 'super');
          this.token('CALL_START', '(');
          this.token('CALL_END', ')');
          [input, sup] = regExSuper;
          return sup.length + 3;
        }
        prev = this.prev();
        // TODO: When changing the '@' symbol for accessing this
        // change it here. Also the '::' operator for accessing the prototype
        tag = colon || (prev != null) && (((ref5 = prev[0]) === '.' || ref5 === '?.' || ref5 === '::' || ref5 === '?::') || !prev.spaced && prev[0] === '@') ? 'PROPERTY' : 'IDENTIFIER';
        if (tag === 'IDENTIFIER' && (indexOf.call(JS_KEYWORDS, id) >= 0 || indexOf.call(JAGUAR_KEYWORDS, id) >= 0) && !(this.exportSpecifierList && indexOf.call(JAGUAR_KEYWORDS, id) >= 0)) {
          tag = id.toUpperCase();
          if (tag === 'WHEN' && (ref6 = this.tag(), indexOf.call(LINE_BREAK, ref6) >= 0)) {
            tag = 'LEADING_WHEN';
          } else if (tag === 'FOR') {
            this.seenFor = true;
          } else if (tag === 'UNLESS') {
            tag = 'IF';
          } else if (tag === 'IMPORT') {
            this.seenImport = true;
          } else if (tag === 'EXPORT') {
            this.seenExport = true;
          } else if (indexOf.call(UNARY, tag) >= 0) {
            tag = 'UNARY';
          } else if (indexOf.call(RELATION, tag) >= 0) {
            if (tag !== 'INSTANCEOF' && this.seenFor) {
              tag = 'FOR' + tag;
              this.seenFor = false;
            } else {
              tag = 'RELATION';
              if (this.value() === '!') {
                poppedToken = this.tokens.pop();
                id = '!' + id;
              }
            }
          }
        } else if (tag === 'IDENTIFIER' && this.seenFor && id === 'from' && isForFrom(prev)) {
          tag = 'FORFROM';
          this.seenFor = false;
        } else if (tag === 'PROPERTY' && prev) {
          if (prev.spaced && (ref7 = prev[0], indexOf.call(CALLABLE, ref7) >= 0) && /^[gs]et$/.test(prev[1]) && this.tokens.length > 1 && ((ref8 = this.tokens[this.tokens.length - 2][0]) !== '.' && ref8 !== '?.' && ref8 !== '@')) {
            this.error(`'${prev[1]}' cannot be used as a keyword, or as a function call without parentheses.`, prev[2]);
          } else if (this.tokens.length > 2) {
            prevprev = this.tokens[this.tokens.length - 2];
            // TODO: when changing the '@' symbol for accessing this, change here.
            if (((ref9 = prev[0]) === '@' || ref9 === 'THIS') && prevprev && prevprev.spaced && /^[gs]et$/.test(prevprev[1]) && ((ref10 = this.tokens[this.tokens.length - 3][0]) !== '.' && ref10 !== '?.' && ref10 !== '@')) {
              this.error(`'${prevprev[1]}' cannot be used as a keyword, or as a function call without parentheses`, prevprev[2]);
            }
          }
        }
        if (tag === 'IDENTIFIER' && indexOf.call(RESERVED, id) >= 0) {
          this.error(`reserved word '${id}'`, {
            length: id.length
          });
        }
        if (!(tag === 'PROPERTY' || this.exportSpecifierList)) {
          if (indexOf.call(JAGUAR_ALIASES, id) >= 0) {
            alias = id;
            id = JAGUAR_ALIAS_MAP[id];
          }
          tag = (function() {
            switch (id) {
              case '!':
                return 'UNARY';
              case '==':
              case '!=':
                return 'COMPARE';
              case 'true':
              case 'false':
                return 'BOOL';
              case 'break':
              case 'continue':
              case 'debugger':
                return 'STATEMENT';
              case '&&':
              case '||':
                return id;
              default:
                return tag;
            }
          })();
        }
        tagtoken = this.token(tag, id, 0, idLength);
        if (alias) {
          tagtoken.origin = [tag, alias, tagToken[2]];
        }
        if (poppedToken) {
          [tagToken[2].first_line, tagToken[2].first_column] = [poppedToken[2].first_line, poppedToken[2].first_column];
        }
        if (colon) {
          colonOffset = input.lastIndexOf(':');
          colonToken = this.token(':', ':', colonOffset, colon.length);
        }
        return input.length;
      }
    }

    numberToken() {
      var base, lexedLength, match, number, numberValue, tag;
      if (!(match = NUMBER.exec(this.chunk))) {
        return 0;
      }
      number = match[0];
      lexedLength = number.length;
      switch (false) {
        case !/^0[BOX]/.test(number):
          this.error(`radix prefix in '${number}' must be lowercase`, {
            offset: 1
          });
          break;
        case !/^(?!0x).*E/.test(number):
          this.error(`exponential notation in '${number}' must be indicated with a lowercase 'e'`, {
            offset: number.indexOf('E')
          });
          break;
        case !/^0\d*[89]/.test(number):
          this.error(`decimal literal '${number}' must not be prefixed with '0'`, {
            length: lexedLength
          });
          break;
        case !/^0\d+/.test(number):
          this.error(`octal literal '${number}' must be prefixed with '0o'`, {
            length: lexedLength
          });
      }
      base = (function() {
        switch (number.charAt(1)) {
          case 'b':
            return 2;
          case 'o':
            return 8;
          case 'x':
            return 16;
          default:
            return null;
        }
      })();
      numberValue = base != null ? parseInt(number.slice(2), base) : parseFloat(number);
      tag = numberValue === 2e308 ? 'INFINITY' : 'NUMBER';
      this.token(tag, number, 0, lexedLength);
      return lexedLength;
    }

  };

}).call(this);
