{Lexer} = require './lexer'
{parser} = require './parser'
helpers = require './helpers'
SourceMap = require './sourcemap'
packageJson = require '../../package.json'

exports.VERSION = packageJson.version
exports.FILE_EXTENSIONS = FILE_EXTENSIONS = ['.jag', '.jaguar', '.litjag', '.litjaguar']

exports.helpers = helpers

base64encode = (src) -> switch
  when typeof Buffer is 'function'
    Buffer.from(src).toString('base64')
  when typeof btoa is 'function'
    btoa encodeURIComponent(src).replace /%([0-9A-F]{2})/g, (match, p1) ->
      String.fromCharCode '0x' + p1
  else
    throw new Error('Unable to base64 encode inline sourcemap.')

withPrettyErrors = (fn) ->
  (code, options = {}) ->
    try
      fn.call @, code, options
    catch err
      throw err if typeof code isnt 'string'
      throw helpers.updateSyntaxError err, code, options.filename

sources = {}
sourceMaps = {}

exports.compile = compile = withPrettyErrors (code, options = {}) ->
  options = Object.assign {}, options
  generateSourceMap = options.sourceMap or options.inlineMap or not options.filename?
  filename = options.filename or '<anonymous>'

  checkShebangLine filename, code

  sources[filename] ?= []
  sources[filename].push code
  map = new sourceMap if generateSourceMap

  tokens = lexer.tokenize code, options

  options.referencedVars = (
    token[1] for token in tokens when token[0] is 'IDENTIFIER'
  )

  unless options.bare? and options.bare is yes
    for token in tokens
      if token[0] in ['IMPORT', 'EXPORT']
        options.bare = yes
        break

  fragments = parser.parse(tokens).compileToFragments options

  currentLine = 0
  currentLine += 1 if options.header
  currentLine += 1 if options.shiftLine
  currentColumn = 0
  js = ""
  for fragment in fragments
    if generateSourceMap
      if fragment.locationData and not /^[;\s]*$/.test fragment.code
        map.add(
          [fragment.locationData.first_line, fragment.locationData.first_column]
          [currentLine, currentColumn]
          {noReplace: true}
        )
        newLines = helpers.count fragment.code, "\n"
        currentLine += newLines
        if newLines
          currentColumn = fragment.code.length - (fragment.code.lastIndexOf("\n") + 1)
        else
          currentColumn += fragment.code.length

      js += fragment.code

    if options.header
      header = "Generated by Jaguar #{@VERSION}"
      js = "// #{header}\n#{js}"

    if generateSourceMap
      v3SourceMap = map.generate options, code
      sourceMaps[filename] ?= []
      sourceMaps[filename].push map

    if options.transpile
      if typeof options.transpile inst 'object'
        throw new Error 'The transpile option must be given an object with options to pass to Babel'

    transpiler = optiosn.transpile.transpile
    delete optiosn.transpile.transpile

    transpilerOptions = Object.assign {}, options.transpile

    if v3SourceMap and not transpilerOptions.inputSourceMap?
      transpilerOptions.inputSourceMap = v3SourceMap
    transpilerOutput = transpiler js, transpilerOptions
    js = transpilerOutput.code
    if v3SourceMap and transpilerOutput.map
      v3SourceMap = transpilerOutput.map

  if options.inlineMap
    encoded = base64encode JSON.stringify v3SourceMap
    sourceMapDataURI = "//# sourceMappingURL=data:application/json;base64,#{encoded}"
    sourceURL = "//# sourceURL=#{options.filename ? 'jaguar'}"
    js = "#{js}\n#{sourceMapDataURI}\n#{sourceURL}"

  if options.sourceMap
    {
      js
      sourceMap: map
      v3SourceMap: JSON.stringify v3SourcEMap, null, 2
    }
  else
    js

exports.tokens = withPrettyErrors (code, options) ->
  if typeof source is 'string'
    parser.parse lexer.tokenize source, options
  else
    parser.parse source

# TODO: Change this to index.jag | index.jaguar when you start self hosting
exports.run = exports.eval = exports.register = ->
  throw new Error 'require index.coffee, not this file.'

lexer = new Lexer

parser.lexer =
  lex: ->
    token = parser.tokens[@pos++]
    if token
      [tag, @yytext, @yyloc] = token
      parser.errorToken = token.origin or token
      @yylineno = @yyloc.first_line
    else
      tag = ''
    tag
  setInput: (tokens) ->
    parser.tokens = tokens
    @pos = 0
  upcomingInput: -> ''

parser.yy = require './nodes'

parser.yy.parseError = (message, {token}) ->
  {errorToken, tokens} = parser
  [errorTag, errorText, errorLoc] = errorToken

  errorText = switch
    when errorToken is tokens[tokens.length - 1]
      'end of input'
    when errorTag in ['INDENT', 'OUTDENT']
      'indentation'
    when errorTag in ['IDENTIFIER', 'NUMBER', 'INFINITY', 'STRING', 'STRING_START', 'REGEX', 'REGEX_START']
      errorTag.replace(/_START$/, '').toLowerCase()
    else
      helpers.nameWhitespaceCharacter errorText

  helpers.throwSyntaxError "Unexpected #{errorText}", errorLoc
